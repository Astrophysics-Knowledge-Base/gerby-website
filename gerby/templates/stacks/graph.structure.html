<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v3.min.js""></script>

<style type="text/css">
.link {
  stroke: #999;
  stroke-opacity: .6;
}
</style>
  </head>
  <body>
<svg id="graph"></svg>

<script>
// zoom event for force-directed and collapsible
var zoom = d3.behavior.zoom()
  .scaleExtent([0.2, 2])
  .on("zoom", redraw);

// redraw the svg (or rather the <g> inside <svg>) on a zoom event
function redraw() {
  if (!global["mouseDownOnNode"])
    vis.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
}

function namedClass(node) {
  if (node.type == "item" || node.type == "equation")
    return "unnamed";

  if (node.tagName != "")
    return "named";
  else
    return "unnamed";
}


var width = 1000;
var height = 1000;

var force = d3.layout.force()
    .charge(-500)
    .linkDistance(10)
    .gravity(.5)
    .size([width, height]);

d3.select("body").append("div").attr("id", "graph");

var svg = d3.select("div#graph").append("svg")
    .attr("width", width + "px")
    .attr("height", height + "px")
    .call(zoom);

var vis = svg.append("svg:g");

var global = Array(); // this catches some things that need to be available globally
global["mouseDownOnNode"] = false;


result = d3.json("/data/tag/{{ tag.tag }}/graph/structure", function(error, graph) {
  var heatMaxSize = 0; // this corresponds to the depth variable, and starts with 0 at the root node
  var heatMinSize = 0; // this corresponds to the size variable, and starts with 0 at a leaf node, taking the maximum over the children + 1 as the value for a parent

  for (var i = 0; i < graph.nodes.length; i++) {
    heatMaxSize = Math.max(heatMaxSize, graph.nodes[i].depth);
    heatMinSize = Math.max(heatMinSize, graph.nodes[i].size);
  }
  // heat scales
  var heatMapMax = d3.scale.linear()
    .domain([0, heatMaxSize / 2.0, 3.0 * heatMaxSize / 4.0, heatMaxSize])
    .range(["red", "yellow", "green", "blue"]);
  var heatMapMin = d3.scale.linear()
    .domain([0, heatMaxSize / 2.0, 3.0 * heatMinSize / 4.0, heatMinSize])
    .range(["red", "yellow", "green", "blue"]);

  function colorHeatMax(node) { return heatMapMax(node.depth); }
  function colorHeatMin(node) { return heatMapMin(heatMinSize - node.size); }
  function colorType(node) { return typeMap(node.type); }
  function colorChapters(node) { return chapterMap(chapters[node.file]); }

  force
    .nodes(graph.nodes)
    .links(graph.links)
    .start();

  var link = vis.selectAll(".link")
    .data(graph.links)
    .enter().append("line")
    .attr("class", "link")

  var node = vis.selectAll(".node")
    .data(graph.nodes)
    .enter().append("circle")
    .attr("class", namedClass)
    .attr("id", function(d) { if (d.depth == 0) { return "root"; } })
    .attr("r", function(d) { return 4 * Math.pow(parseInt(d.size) + 1, 1 / 3); })
    .style("fill", function(d) { colorMapping = colorHeatMax; return colorHeatMax(d); })
    .on("mousedown", function(d) { global["mouseDownOnNode"] = true; })
    .on("mouseup", function(d) { global["mouseDownOnNode"] = false; })
    .on("dblclick", function(node) { openTag(node, "force"); })
    .on("contextmenu", function(node) { openTagNew(node, "force"); })
    .call(force.drag);

  force.on("tick", function() {
    link
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

    node
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
  });
});

</script>
  </body>
</html>
